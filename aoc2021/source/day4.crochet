% crochet

singleton day4;


// -- Parsing. It's always parsing...
type day4-data(
  global input is list<integer>,
  global boards is list<day4-board>,
);

type day4-board(
  global rows is list<list<integer>>
);

implement equality for day4-data;
command day4-data === (That is day4-data) =
  (self input === That input) and (self boards === That boards);

implement equality for day4-board;
command day4-board === (That is day4-board) =
  self rows === That rows;

command day4 parse: (Input is text) do
  let Tree = d4-grammar parse: Input;
  condition
    when Tree is error => panic message: Tree reason tag: "syntax-error";
    when Tree is ok => Tree value normalise;
  end
test
  assert (day4 parse: day4 example-input) === new day4-data(
    [7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1],
    [
      new day4-board([
        [22, 13, 17, 11,  0],
        [ 8,  2, 23,  4, 24],
        [21,  9, 14, 16,  7],
        [ 6, 10,  3, 18,  5],
        [ 1, 12, 20, 15, 19],
      ]),
      
      new day4-board([
        [ 3, 15,  0,  2, 22],
        [ 9, 18, 13, 17,  5],
        [19,  8,  7, 25, 23],
        [20, 11, 10, 24,  4],
        [14, 21, 16, 12,  6],
      ]),

      new day4-board([
        [14, 21, 17, 24,  4],
        [10, 16, 15,  9, 19],
        [18,  8, 23, 26, 20],
        [22, 11, 13,  6,  5],
        [ 2,  0, 12,  3,  7],
      ]),
    ]
  );
end

command d4-number normalise = #integer try-parse: self.value | value-or-panic: "not an integer";
command d4-input normalise = self.numbers map: (_ normalise);
command d4-board normalise = new day4-board(self.rows map: (_ normalise));
command d4-row normalise = self.columns map: (_ normalise);
command d4-data normalise = new day4-data(self.input normalise, self.boards map: (_ normalise));


// -- Logical modelling
relation d4-game: Game*;
relation Game* d4-game-board: Board*;
relation Game* d4-game-input: Input;
relation Game* d4-game-drawn: Number;
relation Game* d4-game-state: State;
relation Board* d4-board-rows: Rows columns: Columns;
relation Board* d4-board-number: Number* marked: Boolean;
relation Board* d4-board-number: Number* row: Row column: Column;

// Manual indexes (for now)
relation Board* d4-board-won: Boolean;
relation Board* d4-board-row: Row* marks: Marks;
relation Board* d4-board-column: Column* marks: Marks;

type d4m-game;
type d4m-board;
enum d4m-state = d4m-on-going, d4m-ended;

command day4 make-game: (Data is day4-data) do
  let Game = new d4m-game;
  fact d4-game: Game;
  fact Game d4-game-input: (Data input);
  fact Game d4-game-state: d4m-on-going;

  // Initialising the boards
  for Board-data in Data boards do
    let Board = new d4m-board;
    fact Game d4-game-board: Board;
    fact Board d4-board-won: false;
    fact Board d4-board-rows: (Board-data rows count)
               columns: (Board-data rows first count);

    // Initialising the numbers on the boards and their "mark" status
    for Row in Board-data rows enumerate, Column in Row value enumerate do
      fact Board d4-board-number: (Column value) marked: false;
      fact Board d4-board-number: (Column value)
                 row: (Row index)
                 column: (Column index);
    end

    // Keeping track of how many marks we have on each row/column
    for Row in 1 to: Board-data rows count do
      fact Board d4-board-row: Row marks: 0;
    end

    for Column in 1 to: Board-data rows first count do
      fact Board d4-board-column: Column marks: 0;
    end
  end

  Game;
end

command d4m-board mark: (Number is integer) do
  match
    when
      self d4-board-number: Number marked: Is-marked,
      self d4-board-number: Number row: Row column: Column,
      self d4-board-row: Row marks: Row-marks,
      self d4-board-column: Column marks: Column-marks
    do
      assert not Is-marked;
      fact self d4-board-number: Number marked: true;
      fact self d4-board-row: Row marks: (Row-marks + 1);
      fact self d4-board-column: Column marks: (Column-marks + 1);
    end

    when not self d4-board-number: Number marked: _ do
      nothing
    end
  end
end

command d4m-game play do
  simulate for [self] in day4 until self d4-game-state: d4m-ended;
end

command d4m-game state =
  (search self d4-game-state: State).State first;

command d4m-game boards =
  (search self d4-game-board: Board).Board;

command d4m-game winning-board
requires ended :: self state === d4m-ended
do
  (search self d4-game-board: Board, Board d4-board-won: true).Board first;
end

command d4m-game last-drawn =
  (search self d4-game-drawn: Number).Number first;

command d4m-game score
requires ended :: self state === d4m-ended
do
  self winning-board unmarked-numbers sum * self last-drawn;
end

command d4m-board unmarked-numbers =
  (search self d4-board-number: Number marked: false).Number;


context day4 with
  action (Game is d4m-game) step "Draw the next number"
  when
    Game d4-game-state: d4m-on-going,
    Game d4-game-input: Input,
    if not Input is-empty,
    let Boards = search Game d4-game-board: Board
  do
    let Drawn = Input first;
    let Remaining = Input rest;
    fact Game d4-game-drawn: Drawn;
    fact Game d4-game-input: Remaining;
    Boards.Board map: (_ mark: Drawn);
  end

  when
    d4-game: Game,
    Game d4-game-state: d4m-on-going,
    Game d4-game-board: Board,
    Board d4-board-rows: Rows columns: Columns,
    (Board d4-board-row: _ marks: Columns | Board d4-board-column: _ marks: Rows)
  do
    fact Board d4-board-won: true;
    fact Game d4-game-state: d4m-ended;
  end  
end

command day4 part1: Input do
  let Data = day4 parse: Input;
  let Game = day4 make-game: Data;
  Game play;
  Game score;
test
  assert (day4 part1: day4 example-input) === 4_512;  
end

command day4 part1 do
  day4 part1: day4 input;
test
  assert day4 part1 === 8_442;
end